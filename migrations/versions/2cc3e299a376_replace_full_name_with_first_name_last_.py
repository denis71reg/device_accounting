"""Replace full_name with first_name, last_name, middle_name in employees

Revision ID: 2cc3e299a376
Revises: 5d35d8b8be66
Create Date: 2025-11-28 00:01:29.742639

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy import inspect as sqlalchemy_inspect


# revision identifiers, used by Alembic.
revision = '2cc3e299a376'
down_revision = '5d35d8b8be66'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    connection = op.get_bind()
    
    # Проверяем, какие колонки уже существуют
    inspector = sqlalchemy_inspect(connection)
    existing_columns = [col['name'] for col in inspector.get_columns('employees')]
    
    # Добавляем новые поля только если их еще нет
    if 'first_name' not in existing_columns:
        with op.batch_alter_table('employees', schema=None) as batch_op:
            batch_op.add_column(sa.Column('first_name', sa.String(), nullable=True))
            batch_op.add_column(sa.Column('last_name', sa.String(), nullable=True))
            batch_op.add_column(sa.Column('middle_name', sa.String(), nullable=True))
    
    # Заполняем новые поля данными из full_name (только если full_name еще существует)
    if 'full_name' in existing_columns:
        employees = connection.execute(sa.text("SELECT id, full_name FROM employees")).fetchall()
        
        for emp_id, full_name in employees:
            # Разбиваем ФИО на части (формат: "Фамилия Имя Отчество")
            parts = full_name.strip().split() if full_name else []
            if len(parts) >= 2:
                last_name = parts[0]
                first_name = parts[1]
                middle_name = " ".join(parts[2:]) if len(parts) > 2 else None
            elif len(parts) == 1:
                # Если только одно слово, считаем его фамилией
                last_name = parts[0]
                first_name = ""
                middle_name = None
            else:
                last_name = ""
                first_name = ""
                middle_name = None
            
            connection.execute(
                sa.text("UPDATE employees SET first_name = :first_name, last_name = :last_name, middle_name = :middle_name WHERE id = :id"),
                {"first_name": first_name, "last_name": last_name, "middle_name": middle_name, "id": emp_id}
            )
    
    # Теперь делаем поля not null и удаляем full_name
    with op.batch_alter_table('employees', schema=None) as batch_op:
        # Проверяем, нужно ли изменить nullable
        if 'first_name' in existing_columns:
            # Проверяем, есть ли NULL значения
            try:
                null_count = connection.execute(sa.text("SELECT COUNT(*) FROM employees WHERE first_name IS NULL OR last_name IS NULL")).scalar()
                if null_count > 0:
                    # Заполняем пустые значения
                    connection.execute(sa.text("UPDATE employees SET first_name = 'Unknown' WHERE first_name IS NULL"))
                    connection.execute(sa.text("UPDATE employees SET last_name = 'Unknown' WHERE last_name IS NULL"))
            except Exception:
                pass
            try:
                batch_op.alter_column('first_name', nullable=False)
                batch_op.alter_column('last_name', nullable=False)
            except Exception:
                pass  # Колонки могут уже быть not null
        
        # Удаляем full_name если он еще существует
        if 'full_name' in existing_columns:
            try:
                batch_op.drop_column('full_name')
            except Exception:
                pass  # Колонка может уже быть удалена
        
        # Добавляем уникальный индекс на комбинацию ФИО (если его еще нет)
        try:
            constraints = [c['name'] for c in inspector.get_unique_constraints('employees')]
            if 'uq_employees_name' not in constraints:
                batch_op.create_unique_constraint('uq_employees_name', ['first_name', 'last_name', 'middle_name'])
        except Exception:
            # Если не удалось проверить, просто пытаемся создать ограничение
            try:
                batch_op.create_unique_constraint('uq_employees_name', ['first_name', 'last_name', 'middle_name'])
            except Exception:
                pass  # Ограничение может уже существовать

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    # Добавляем full_name как nullable
    with op.batch_alter_table('employees', schema=None) as batch_op:
        batch_op.add_column(sa.Column('full_name', sa.VARCHAR(), nullable=True))
    
    # Заполняем full_name из отдельных полей
    connection = op.get_bind()
    employees = connection.execute(sa.text("SELECT id, first_name, last_name, middle_name FROM employees")).fetchall()
    
    for emp_id, first_name, last_name, middle_name in employees:
        parts = [last_name or "", first_name or ""]
        if middle_name:
            parts.append(middle_name)
        full_name = " ".join(parts).strip()
        if not full_name:
            full_name = "Unknown"
        
        connection.execute(
            sa.text("UPDATE employees SET full_name = :full_name WHERE id = :id"),
            {"full_name": full_name, "id": emp_id}
        )
    
    # Делаем full_name not null и удаляем новые поля
    with op.batch_alter_table('employees', schema=None) as batch_op:
        batch_op.alter_column('full_name', nullable=False)
        batch_op.drop_constraint('uq_employees_name', type_='unique')
        batch_op.drop_column('middle_name')
        batch_op.drop_column('last_name')
        batch_op.drop_column('first_name')
        # Восстанавливаем уникальный индекс на full_name
        batch_op.create_unique_constraint('uq_employees_full_name', ['full_name'])

    # ### end Alembic commands ###
